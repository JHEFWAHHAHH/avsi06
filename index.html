<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <title>Avoid LTN</title>
  <style>
    :root {
      --sky-top: #6ec6ff;
      --sky-mid: #a6ddff;
      --sky-bot: #e9f7ff;
      --accent: #ff3b3b;
      --hud: rgba(0,0,0,0.45);
      --hud-text: #ffffff;
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: linear-gradient(180deg, var(--sky-top) 0%, var(--sky-mid) 60%, var(--sky-bot) 100%);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: #14323f;
    }
    #game {
      display: block;
      width: 100vw;
      height: 100vh;
      touch-action: none; /* allow custom touch handling */
    }
    .hud {
      position: fixed;
      top: env(safe-area-inset-top, 0);
      left: env(safe-area-inset-left, 0);
      right: env(safe-area-inset-right, 0);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      padding: 10px 14px;
      pointer-events: none; /* clicks pass through */
    }
    .hud .panel {
      pointer-events: auto; /* but controls inside should work */
      background: var(--hud);
      border-radius: 12px;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      color: var(--hud-text);
      padding: 8px 12px;
      display: inline-flex;
      align-items: center;
      gap: 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.15);
    }
    .hud .stat {
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      letter-spacing: 0.3px;
    }
    .hud .controls label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      opacity: 0.95;
    }
    .hud input[type="file"] {
      color: #fff;
      font-size: 12px;
      max-width: 52vw;
    }
    .overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: radial-gradient(1200px 500px at 50% 20%, rgba(255,255,255,0.7), rgba(200,230,255,0.75), rgba(160,210,255,0.9));
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      z-index: 4;
    }
    .card {
      width: min(92vw, 720px);
      background: #ffffffee;
      border-radius: 16px;
      box-shadow: 0 20px 50px rgba(0,0,0,0.15);
      padding: 22px 22px 18px;
      border: 1px solid rgba(10,80,120,0.1);
    }
    .card h1 { margin: 0 0 6px; font-size: clamp(22px, 4.5vw, 32px); }
    .card p { margin: 6px 0; line-height: 1.4; }
    .card .row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; margin-top: 10px; }
    .btn {
      appearance: none;
      border: none;
      background: var(--accent);
      color: white;
      padding: 10px 16px;
      border-radius: 12px;
      font-weight: 700;
      letter-spacing: 0.3px;
      box-shadow: 0 8px 18px rgba(255,59,59,0.35);
      cursor: pointer;
      transition: transform .06s ease;
    }
    .btn:active { transform: translateY(1px) scale(0.99); }
    .icon-btn {
      appearance: none;
      width: 36px;
      height: 36px;
      background: transparent;
      border: none;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      padding: 0;
      box-shadow: none;
      color: #fff;
    }
    .icon-btn:hover { background: rgba(255,255,255,0.08); }
    .icon-btn:active { transform: translateY(1px) scale(0.98); }
    .muted { opacity: 0.8; font-size: 13px; }
    .legend { font-size: 13px; opacity: 0.9; }
    .hidden { display: none !important; }
    /* Game over card tweaks */
    #gameover .card.gameover-card {
      width: min(80vw, 320px);
      border-radius: 0;
      padding: 16px;
      display: grid;
      gap: 12px;
      justify-items: center;
      text-align: center;
    }
    #gameover .score {
      font-size: clamp(28px, 6vw, 44px);
      font-weight: 800;
      color: #14323f;
      margin: 4px 0 8px;
    }
    .btn.big {
      width: 100%;
      padding: 14px 18px;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="hud">
    <div class="panel">
      <div class="stat" id="altitude">word: 0 m</div>
    </div>
    <div class="panel controls">
      <!-- Set photos once (persisted) -->
      <button class="icon-btn" id="setBalloonBtn" title="Set balloon photo" aria-label="Set balloon photo">
        <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="22" height="22" aria-hidden="true">
          <path d="M4 7h3l2-3h6l2 3h3a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2z" />
          <circle cx="12" cy="13" r="3" />
        </svg>
      </button>
      <button class="icon-btn" id="setMinesBtn" title="Set mine photos" aria-label="Set mine photos">
        <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="22" height="22" aria-hidden="true">
          <rect x="3" y="5" width="18" height="14" rx="2" ry="2" />
          <path d="M8 11l2 2 4-4" />
        </svg>
      </button>
      <input type="file" id="balloonInput" accept="image/*" style="display:none" />
      <input type="file" id="minesInput" accept="image/*" multiple style="display:none" />
      <button class="icon-btn" id="restartBtn" title="Restart" aria-label="Restart">
        <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="22" height="22" aria-hidden="true">
          <path d="M3 12a9 9 0 1 1 3 6.7" />
          <polyline points="3 3 3 9 9 9" />
        </svg>
      </button>
    </div>
  </div>

  <div class="overlay hidden" id="gameover">
    <div class="card gameover-card">
      <div id="finalStats" class="score">0 m</div>
      <button class="btn big" id="againBtn">Restart</button>
    </div>
  </div>

  <script>
  (() => {
    // Canvas setup with HiDPI scaling
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    function resize() {
      DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const w = Math.floor(window.innerWidth);
      const h = Math.floor(window.innerHeight);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      canvas.width = Math.floor(w * DPR);
      canvas.height = Math.floor(h * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // scale drawing to CSS pixels
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    // Game state
    const STATE = { Menu: 'menu', Playing: 'playing', GameOver: 'gameover' };
    let state = STATE.Playing; // start immediately

    // UI
    const altitudeEl = document.getElementById('altitude');
        const againBtn = document.getElementById('againBtn');
    const restartBtn = document.getElementById('restartBtn');
    const gameoverOverlay = document.getElementById('gameover');
    const finalStats = document.getElementById('finalStats');
    const setBalloonBtn = document.getElementById('setBalloonBtn');
    const setMinesBtn = document.getElementById('setMinesBtn');
    const balloonInput = document.getElementById('balloonInput');
    const minesInput = document.getElementById('minesInput');

    // Controls: shield cursor
    const pointer = { x: window.innerWidth * 0.5, y: window.innerHeight * 0.7, active: false };
    const shield = { r: 26, color: 'rgba(255,255,255,0.9)' };

    function setPointerFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      pointer.x = Math.max(0, Math.min(rect.width, clientX - rect.left));
      pointer.y = Math.max(0, Math.min(rect.height, clientY - rect.top));
      pointer.active = true;
    }
    window.addEventListener('mousemove', setPointerFromEvent, { passive: true });
    window.addEventListener('touchstart', (e) => { e.preventDefault(); setPointerFromEvent(e); }, { passive: false });
    window.addEventListener('touchmove', (e) => { e.preventDefault(); setPointerFromEvent(e); }, { passive: false });
    window.addEventListener('touchend', () => { pointer.active = false; }, { passive: true });

    // Balloon with optional photo
    const balloon = {
      x: () => canvas.width / DPR * 0.5,
      y: () => canvas.height / DPR * 0.75,
      r: () => Math.min(canvas.width / DPR, canvas.height / DPR) * 0.09,
      wobbleT: 0,
      img: null,
      imgReady: false,
    };

    function loadBalloonFromDataURL(dataURL) {
      if (!dataURL) return;
      const img = new Image();
      img.onload = () => {
        balloon.img = img;
        balloon.imgReady = true;
      };
      img.src = dataURL;
    }

    const PRESET_BALLOON_IMAGE_URL = 'main.jpg';
    function loadBalloonFromURL(url) {
      if (!url) return;
      const img = new Image();
      img.onload = () => {
        balloon.img = img;
        balloon.imgReady = true;
      };
      img.src = url;
    }

    function loadImageFromFile(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        const dataURL = reader.result;
        try { localStorage.setItem('balloonPhoto', dataURL); } catch {}
        loadBalloonFromDataURL(dataURL);
      };
      reader.readAsDataURL(file);
    }

    const mineImages = [];
    // Place any image URLs or relative paths here to preload mine photos.
    // Example: 'images/m1.jpg', 'images/m2.png', 'https://example.com/p.jpg'
    const PRESET_MINE_IMAGE_URLS = [
      'fat1.jpg',
      'fat3.jpg',
      'fat6.jpg',
      'fat7.jpg',
    ];

    function loadMineImagesFromURLs(urls) {
      if (!urls || !urls.length) return;
      urls.forEach(url => {
        const img = new Image();
        img.onload = () => { mineImages.push(img); };
        img.src = url;
      });
    }
    function loadMineImagesFromFiles(fileList) {
      if (!fileList || fileList.length === 0) return;
      const dataURLs = [];
      let remaining = fileList.length;
      Array.from(fileList).forEach(file => {
        const reader = new FileReader();
        reader.onload = () => {
          const dataURL = reader.result;
          dataURLs.push(dataURL);
          const img = new Image();
          img.onload = () => { mineImages.push(img); };
          img.src = dataURL;
          remaining--;
          if (remaining === 0) {
            try { localStorage.setItem('minePhotos', JSON.stringify(dataURLs)); } catch {}
          }
        };
        reader.readAsDataURL(file);
      });
    }

    function initPhotosFromStorage() {
      const b = localStorage.getItem('balloonPhoto');
      if (b) {
        loadBalloonFromDataURL(b);
      } else {
        loadBalloonFromURL(PRESET_BALLOON_IMAGE_URL);
      }
      loadMineImagesFromURLs(PRESET_MINE_IMAGE_URLS);
      const ms = localStorage.getItem('minePhotos');
      if (ms) {
        try {
          const arr = JSON.parse(ms);
          if (Array.isArray(arr)) {
            arr.forEach(url => {
              const img = new Image();
              img.onload = () => { mineImages.push(img); };
              img.src = url;
            });
          }
        } catch {}
      }
    }

    // HUD photo pickers
    setBalloonBtn && setBalloonBtn.addEventListener('click', () => balloonInput && balloonInput.click());
    setMinesBtn && setMinesBtn.addEventListener('click', () => minesInput && minesInput.click());
    balloonInput && balloonInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      loadImageFromFile(file);
    });
    minesInput && minesInput.addEventListener('change', (e) => {
      const files = e.target.files;
      loadMineImagesFromFiles(files);
    });

    // Clouds background layers
    const clouds = [];
    const cloudLayers = 3; // parallax layers

    function spawnCloud(layer) {
      const w = canvas.width / DPR;
      const h = canvas.height / DPR;
      const baseSize = [38, 64, 94][layer];
      const size = baseSize + Math.random() * baseSize;
      const y = Math.random() * h * 0.9;
      const dir = Math.random() < 0.5 ? -1 : 1;
      const speed = (0.05 + Math.random() * 0.18) * (layer + 1) * dir;
      const x = dir < 0 ? w + size : -size;
      const alpha = [0.25, 0.35, 0.5][layer];
      const puffCount = 4 + Math.floor(Math.random() * 4);
      const puffs = Array.from({ length: puffCount }, () => ({
        ox: (Math.random() * 0.9 + 0.05) * size,
        oy: (Math.random() * 0.5 - 0.25) * size,
        r: (Math.random() * 0.6 + 0.5) * size * 0.45,
      }));
      clouds.push({ x, y, size, speed, alpha, layer, puffs });
    }

    function ensureClouds() {
      const target = 10; // total across layers
      while (clouds.length < target) {
        const layer = Math.floor(Math.random() * cloudLayers);
        spawnCloud(layer);
      }
    }

    // LTN mines
    const mines = [];
    let spawnTimer = 0;

    function spawnMine() {
      const w = canvas.width / DPR;
      const r = 18 + Math.random() * 12; // slightly bigger mines
      const x = r + Math.random() * (w - 2 * r);
      const y = -r - Math.random() * 60; // from slightly above the top
      const vy = 0.9 + Math.random() * 1.6; // fall speed
      const vx = (Math.random() - 0.5) * 0.6; // small drift
      const spin = (Math.random() * 2 - 1) * 0.02;
      const img = (typeof mineImages !== 'undefined' && mineImages.length)
        ? mineImages[Math.floor(Math.random() * mineImages.length)]
        : null;
      mines.push({ x, y, r, vx, vy, ax: 0, ay: 0, angle: Math.random() * Math.PI * 2, spin, img });
    }

    function resetGame() {
      mines.length = 0;
      clouds.length = 0;
      ensureClouds();
      spawnTimer = 0;
      elapsed = 0;
      altitude = 0;
    }

    // Progress
    let elapsed = 0; // seconds
    let altitude = 0; // meters

    // Game loop
    let lastT = performance.now();
    function loop(now) {
      const dt = Math.min(0.033, (now - lastT) / 1000); // clamp to ~30 fps max step
      lastT = now;
      if (state === STATE.Playing) update(dt);
      render();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    function update(dt) {
      elapsed += dt;
      altitude += 2.0 * dt * 10; // 20 m per second for feel

      // Difficulty scaling
      const difficulty = Math.min(1.8, 1 + elapsed * 0.05); // slowly increase spawn rate & speed

      // Spawn mines
      spawnTimer -= dt;
      if (spawnTimer <= 0) {
        spawnMine();
        spawnTimer = Math.max(0.25, 0.9 - elapsed * 0.02); // faster over time
      }

      // Update mines
      const w = canvas.width / DPR;
      const h = canvas.height / DPR;

      for (let i = mines.length - 1; i >= 0; i--) {
        const m = mines[i];
        // Gravity-like fall + slight acceleration to simulate the balloon rising
        m.vy += 0.02 * dt * 60 * difficulty * 0.2; // subtle

        // Shield interaction (repulsion)
        const dx = m.x - pointer.x;
        const dy = m.y - pointer.y;
        const dist = Math.hypot(dx, dy);
        const minDist = m.r + shield.r;
        if (dist < minDist) {
          const nx = dist > 0 ? dx / dist : 1;
          const ny = dist > 0 ? dy / dist : 0;
          const overlap = (minDist - dist);
          // push out of the shield
          m.x += nx * overlap * 0.8;
          m.y += ny * overlap * 0.8;
          // add velocity away to "deflect"
          const push = 2.0 + Math.min(3.5, 0.02 * elapsed);
          m.vx += nx * push;
          m.vy += ny * push;
        }

        // Update position
        m.x += m.vx * dt * 60;
        m.y += m.vy * dt * 60;
        m.angle += m.spin * dt * 60;

        // Wall bounce on sides for variety
        if (m.x < m.r) { m.x = m.r; m.vx *= -0.6; }
        if (m.x > w - m.r) { m.x = w - m.r; m.vx *= -0.6; }

        // Remove if far below screen
        if (m.y - m.r > h + 120) {
          mines.splice(i, 1);
        }
      }

      // Balloon wobble
      balloon.wobbleT += dt;

      // Collision: mine with balloon
      const bx = balloon.x() + Math.sin(balloon.wobbleT * 1.6) * balloon.r() * 0.08;
      const by = balloon.y() + Math.cos(balloon.wobbleT * 1.1) * balloon.r() * 0.06;
      const br = balloon.r();
      for (let i = 0; i < mines.length; i++) {
        const m = mines[i];
        const dx = m.x - bx;
        const dy = m.y - by;
        const d = Math.hypot(dx, dy);
        if (d < (m.r + br * 0.85)) { // a bit generous to balloon
          // Game over
          state = STATE.GameOver;
          gameoverOverlay.classList.remove('hidden');
          finalStats.textContent = `${Math.floor(altitude)} m`;
          break;
        }
      }

      // HUD
      altitudeEl.textContent = `word: ${Math.floor(altitude)} m`;
      
      // Clouds update
      for (let i = clouds.length - 1; i >= 0; i--) {
        const c = clouds[i];
        c.x += c.speed * dt * 60;
        if (c.speed < 0 && c.x < -c.size * 2) clouds.splice(i, 1);
        if (c.speed > 0 && c.x > (w + c.size * 2)) clouds.splice(i, 1);
      }
      ensureClouds();
    }

    function render() {
      const w = canvas.width / DPR;
      const h = canvas.height / DPR;

      // Sky gradient background (matches CSS but dynamic per-frame if desired)
      const grad = ctx.createLinearGradient(0, 0, 0, h);
      grad.addColorStop(0, getComputedStyle(document.documentElement).getPropertyValue('--sky-top'));
      grad.addColorStop(0.6, getComputedStyle(document.documentElement).getPropertyValue('--sky-mid'));
      grad.addColorStop(1, getComputedStyle(document.documentElement).getPropertyValue('--sky-bot'));
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);

      // Clouds
      for (let layer = 0; layer < cloudLayers; layer++) {
        ctx.save();
        for (const c of clouds) {
          if (c.layer !== layer) continue;
          ctx.globalAlpha = c.alpha;
          ctx.fillStyle = '#fff';
          // Draw simple puffed cloud
          ctx.beginPath();
          ctx.arc(c.x, c.y, c.size * 0.35, 0, Math.PI * 2);
          for (const p of c.puffs) {
            ctx.moveTo(c.x + p.ox + p.r, c.y + p.oy);
            ctx.arc(c.x + p.ox, c.y + p.oy, p.r, 0, Math.PI * 2);
          }
          ctx.fill();
        }
        ctx.restore();
      }

      // Mines
      for (const m of mines) {
        drawMine(m);
      }

      // Balloon
      drawBalloon();

      // Shield cursor on top
      drawShield();
    }

    function drawShield() {
      const g = ctx.createRadialGradient(pointer.x, pointer.y, 2, pointer.x, pointer.y, shield.r);
      g.addColorStop(0, 'rgba(255,255,255,0.95)');
      g.addColorStop(1, 'rgba(255,255,255,0.6)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(pointer.x, pointer.y, shield.r, 0, Math.PI * 2);
      ctx.fill();

      // Subtle outline
      ctx.strokeStyle = 'rgba(255,255,255,0.9)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function drawBalloon() {
      const x = balloon.x() + Math.sin(balloon.wobbleT * 1.6) * balloon.r() * 0.08;
      const y = balloon.y() + Math.cos(balloon.wobbleT * 1.1) * balloon.r() * 0.06;
      const r = balloon.r();

      // String
      ctx.strokeStyle = 'rgba(120,90,60,0.8)';
      ctx.lineWidth = Math.max(1.2, r * 0.03);
      ctx.beginPath();
      ctx.moveTo(x, y + r * 0.95);
      ctx.bezierCurveTo(x - r * 0.2, y + r * 1.3, x + r * 0.25, y + r * 1.8, x, y + r * 2.2);
      ctx.stroke();

      // Balloon body
      const grad = ctx.createLinearGradient(x - r, y - r, x + r, y + r);
      grad.addColorStop(0, '#ff5a4f');
      grad.addColorStop(0.5, '#ff2f2f');
      grad.addColorStop(1, '#d31919');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(x, y, r * 0.95, r * 1.1, 0, 0, Math.PI * 2);
      ctx.fill();

      // Photo window (clip circle)
      const innerR = r * 0.65;
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, innerR, 0, Math.PI * 2);
      ctx.clip();
      if (balloon.imgReady && balloon.img) {
        // cover the circle with the image maintaining aspect
        const img = balloon.img;
        const aspect = img.width / img.height;
        const targetSize = innerR * 2;
        let drawW, drawH;
        if (aspect > 1) { // wider
          drawH = targetSize;
          drawW = targetSize * aspect;
        } else {
          drawW = targetSize;
          drawH = targetSize / aspect;
        }
        ctx.drawImage(img, x - drawW / 2, y - drawH / 2, drawW, drawH);
      } else {
        // Default pattern if no photo
        const g = ctx.createLinearGradient(x - innerR, y - innerR, x + innerR, y + innerR);
        g.addColorStop(0, '#fff3');
        g.addColorStop(1, '#0001');
        ctx.fillStyle = g;
        ctx.fillRect(x - innerR, y - innerR, innerR * 2, innerR * 2);
      }
      ctx.restore();

      // Knot
      ctx.fillStyle = '#9b0e0e';
      ctx.beginPath();
      ctx.moveTo(x - r * 0.08, y + r * 1.0);
      ctx.lineTo(x + r * 0.08, y + r * 1.0);
      ctx.lineTo(x, y + r * 1.2);
      ctx.closePath();
      ctx.fill();

      // Highlight
      ctx.globalAlpha = 0.28;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(x - r * 0.35, y - r * 0.45, r * 0.18, r * 0.35, -0.6, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    function drawMine(m) {
      const { x, y, r, angle } = m;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);

      // Body
      const bodyR = r * 0.78;
      const grad = ctx.createRadialGradient(0, 0, bodyR * 0.2, 0, 0, bodyR);
      grad.addColorStop(0, '#5b6673');
      grad.addColorStop(1, '#2c3440');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(0, 0, bodyR, 0, Math.PI * 2);
      ctx.fill();

      // Spikes
      ctx.strokeStyle = '#2b313a';
      ctx.fillStyle = '#3a4350';
      ctx.lineWidth = Math.max(1.2, r * 0.08);
      const spikes = 8;
      for (let i = 0; i < spikes; i++) {
        const a = (i / spikes) * Math.PI * 2;
        const sx = Math.cos(a);
        const sy = Math.sin(a);
        const inner = bodyR * 0.85;
        const outer = r * 1.08;
        ctx.beginPath();
        ctx.moveTo(sx * inner, sy * inner);
        ctx.lineTo(sx * outer, sy * outer);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(sx * outer, sy * outer, r * 0.08, 0, Math.PI * 2);
        ctx.fill();
      }

      // Center photo if available
      if (m.img) {
        const photoR = bodyR * 0.75;
        ctx.save();
        ctx.beginPath();
        ctx.arc(0, 0, photoR, 0, Math.PI * 2);
        ctx.clip();
        const img = m.img;
        const aspect = img.width / img.height;
        const target = photoR * 2;
        let drawW, drawH;
        if (aspect > 1) { drawH = target; drawW = target * aspect; } else { drawW = target; drawH = target / aspect; }
        ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
        ctx.restore();
      } else {
        // Studs only when no photo to avoid covering the image
        ctx.fillStyle = '#8c96a6';
        for (let i = 0; i < 5; i++) {
          const a = i * (Math.PI * 2 / 5) + 0.3;
          ctx.beginPath();
          ctx.arc(Math.cos(a) * bodyR * 0.55, Math.sin(a) * bodyR * 0.55, r * 0.09, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      ctx.restore();
    }

    // UI wiring
    function startGame() {
      resetGame();
      state = STATE.Playing;
      gameoverOverlay.classList.add('hidden');
    }

    againBtn && againBtn.addEventListener('click', startGame);
    restartBtn && restartBtn.addEventListener('click', startGame);

    // Initialize images from prior selection and start game
    initPhotosFromStorage();
    startGame();
  })();
  </script>
</body>
</html>